<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Learn JavaScript - Codecademy | NickDO.xyz</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Poppins&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="reset.css">
  <link rel="stylesheet" href="style.css">
</head>

<body>

  <main class="wrapper">
    <h1>Codecademy - Learn JavaScript</h1>
    <p>Notes taken while going through the <a
        href="https://www.codecademy.com/learn/introduction-to-javascript">Codecademy Learn JS course</a> </p>

    <h2>Introduction to JavaScript</h2>

    <section>
      <h3>What is JavaScrpit</h3>
      <ul>
        <li>JavaScript is a programming language that is primarily used in web development.</li>
        <li>It is known as the language of most modern web browsers.</li>
        <li>JavaScript has evolved and improved over time, becoming a powerful, flexible, and fast language.</li>
        <li>It is used for web development and beyond, being employed in increasingly complex projects.</li>
        <li>JavaScript is often the first language learned by self-taught coders due to its importance in web
          development.</li>
        <li>It powers the dynamic behavior of websites.</li>
        <li>Learning JavaScript provides a foundation for understanding more complex concepts in programming.</li>
        <li>The introductory concepts covered in this lesson include data types and built-in objects.</li>
      </ul>
    </section>

    <section>
      <h3>Console</h3>
      <ul>
        <li>The console is a panel that displays important messages, such as errors, for developers.</li>
        <li>In JavaScript, the console keyword refers to an object that allows us to log messages and data.</li>
        <li>The console object has a built-in method called .log() for printing or logging to the console.</li>
        <li>We can use console.log() to print values and messages to the console.</li>
        <li>Example: console.log(5) logs the value 5 to the console.</li>
        <li>It is recommended to end each statement with a semicolon, although it is not always required.</li>
        <li>console.log() can be used to print different types of data.</li>
      </ul>
      <img src="./assets/images/consoleLog.jpg" alt="console log">
    </section>

    <section>
      <h3>Comments</h3>
      <ul>
        <li>Comments in JavaScript are used to provide explanations, instructions, or annotations in the code.</li>
        <li>Single line comments start with two forward slashes // and comment out a single line.</li>
        <img src="./assets/images/singleLineComment.jpg" alt="singleline comment">
        <li>Single line comments can also be used after a line of code.</li>
        <img src="./assets/images/inlineComment.jpg" alt="inline comment">
        <li>Multi-line comments start with /* and end with */ and can comment out multiple lines.</li>
        <img src="./assets/images/multiLineComment.jpg" alt="multi line comment">
        <li>Comments can also be used to ignore a section of code in the middle of a line.</li>
        <img src="./assets/images/middleOfLineComment.jpg" alt="middle of line comment">
      </ul>
    </section>

    <section>
      <h3>Data Types</h3>
      <ul>
        <li>Data types classify the different kinds of data used in programming.</li>
        <li>JavaScript has seven fundamental data types: Number, String, Boolean, Null, Undefined, Symbol, and Object.
        </li>
        <li>Primitive data types include Number, String, Boolean, Null, Undefined, and Symbol.</li>
        <li>Objects are more complex and allow for collections of related data.</li>
        <li>Strings are used to represent text and are enclosed in single quotes ('...') or double quotes ("...").</li>
        <li>Numbers can be whole numbers or numbers with decimals.</li>
        <li>Boolean represents true or false values.</li>
        <li>Null represents the intentional absence of a value.</li>
        <li>Undefined represents the absence of a value, indicating that the value does not exist.</li>
        <li>Symbols are unique identifiers used in more complex coding.</li>
        <li>Objects are collections of related data.</li>
        <li>Printing a string is done using console.log('...');.</li>
        <li>Printing a number is done without quotes, such as console.log(40);.</li>
      </ul>
      <img src="./assets/images/datatypes.jpg" alt="datatypes">
    </section>

    <section>
      <h3>Arithmetic Operators</h3>
      <ul>
        <li>Arithmetic operators perform mathematical calculations on numbers in JavaScript.</li>
        <li>The addition operator (+) adds two numbers together.</li>
        <li>The subtraction operator (-) subtracts the second number from the first.</li>
        <li>The multiplication operator (*) multiplies two numbers.</li>
        <li>The division operator (/) divides the first number by the second.</li>
        <li>The remainder operator (%) returns the remainder of the division between two numbers.</li>
        <li>The expression inside console.log() is evaluated, and the result is printed to the console.</li>
        <li>To print the characters as a string, wrap them in quotes.</li>
        <img src="./assets/images/arithmeticOperators.jpg" alt="arithmetic operators">
        <img src="./assets/images/remainderOperator.jpg" alt="remainder operators">
      </ul>
    </section>

    <section>
      <h3>String Concatenation</h3>
      <ul>
        <li>The + operator can be used to concatenate strings in JavaScript.</li>
        <li>When the + operator is used between two strings, it appends the right string to the left string.</li>
        <li>This process of combining strings is called string concatenation.</li>
        <li>Example: console.log('hi' + 'ya'); prints 'hiya'.</li>
        <li>Example: console.log('I love to ' + 'code.'); prints 'I love to code.'.</li>
        <li>When concatenating strings, make sure to include any necessary spaces or punctuation.</li>
        <li>Example: console.log('front ' + 'space'); prints 'front space'.</li>
        <li>Example: console.log('middle' + ' ' + 'space'); prints 'middle space'.</li>
        <li>Multiple concatenations can be chained together to create a final result.</li>
        <img src="./assets/images/stringConcatenation.jpg" alt="string concatenation">
      </ul>
    </section>

    <section>
      <h3>Properties</h3>
      <ul>
        <li>JavaScript saves data as instances of different data types.</li>
        <li>Each data type has specific properties associated with it.</li>
        <li>Properties are accessed using the dot (.) operator.</li>
        <li>Example: console.log('Hello'.length) retrieves the length property of the string instance.</li>
        <li>The value of a property is retrieved from the instance and can be used in the program.</li>
        <img src="./assets/images/propertiesLength.jpg" alt="length property">
      </ul>
    </section>

    <section>
      <h3>Methods</h3>
      <ul>
        <li>Methods in JavaScript are actions that can be performed on data types.</li>
        <li>Data types have specific methods associated with them.</li>
        <li>Methods are called using the dot (.) operator, followed by the method name and parentheses.</li>
        <li>Example: 'example string'.methodName().</li>
        <li>.toUpperCase(): Converts a string to all uppercase letters.</li>
        <li>console.log('hello'.toUpperCase()) prints 'HELLO'.</li>
        <li>.startsWith(): Checks if a string starts with a specified character or string.</li>
        <img src="./assets/images/methods.jpg" alt="methods">
      </ul>
    </section>

    <section>
      <h3>Built-In Objects</h3>
      <ul>
        <li>JavaScript has built-in objects that provide useful functionality.</li>
        <li>One example is the Math object, which allows complex mathematical operations.</li>
        <li>Objects have methods that can be called using the dot (.) operator.</li>
        <li>Example: objectName.methodName().</li>
        <li>The Math object has methods like .random() for generating random numbers.</li>
        <li>Example: console.log(Math.random()) prints a random number between 0 and 1.</li>
        <li>To generate a random number between 0 and a specific range, multiply the result by the range value.</li>
        <li>Example: Math.random() * 50 generates a random number between 0 and 50.</li>
        <li>Math.floor() rounds down a decimal number to the nearest whole number.</li>
        <img src="./assets/images/built-inObjects.jpg" alt="built-in objects">
      </ul>
    </section>

    <section>
      <h3>Review: Introduction</h3>
      <ul>
        <li>Data is printed, or logged, to the console, a panel that displays messages, with console.log().</li>
        <li>We can write single-line comments with // and multi-line comments between /* and */.</li>
        <li>There are 7 fundamental data types in JavaScript: strings, numbers, booleans, null, undefined, symbol, and
          object.</li>
        <li>Numbers are any number without quotes: 23.8879</li>
        <li>Strings are characters wrapped in single or double quotes: 'Sample String'</li>
        <li>The built-in arithmetic operators include +, -, *, /, and %.</li>
        <li>Objects, including instances of data types, can have properties, stored information. The properties are
          denoted with a . after the name of the object, for example: 'Hello'.length. </li>
        <li>Objects, including instances of data types, can have methods which perform actions. Methods are called by
          appending the object or instance with a period, the method name, and parentheses. For example:
          'hello'.toUpperCase().</li>
        <li>We can access properties and methods by using the ., dot operator. </li>
        <li>Built-in objects, including Math, are collections of methods and properties that JavaScript provides.</li>
      </ul>
    </section>

    <h2>Variables</h2>

    <section>
      <h3>Introduction to Variables</h3>
      <ul>
        <li>A variable is a container for a value in programming.</li>
        <li>Variables store information in a computer's memory.</li>
        <li>They provide a way to label data with a descriptive name for clarity.</li>
        <li>Variables can be created with a descriptive name.</li>
        <li>Information can be stored or updated in a variable.</li>
        <li>Variables allow us to reference or retrieve stored information.</li>
        <li>Variables are not values themselves; they contain and represent values with a name.</li>
        <li>They are represented by colored boxes in diagrams, with the content representing the value and the label
          representing the name.</li>
        <li>The lesson covers the usage of the var, let, and const keywords to create variables.</li>
      </ul>
    </section>

    <section>
      <h3>Var Variables</h3>
      <ul>
        <li>Prior to ES6, the var keyword was used to create variables in JavaScript.</li>
        <li>Example: var myName = 'Arya';</li>
        <li>var is short for "variable" and declares a new variable.</li>
        <li>Variable names are written in camel case, starting with a lowercase letter.</li>
        <li>The assignment operator = assigns a value to the variable.</li>
        <li>Variables cannot start with numbers.</li>
        <li>Variable names are case-sensitive.</li>
        <li>Avoid using variable names that are the same as JavaScript keywords.</li>
        <img src="./assets/images/variablesVar.jpg" alt="var variable">
      </ul>
    </section>

    <section>
      <h3>Let Variables</h3>
      <ul>
        <li>The let keyword was introduced in ES6 and allows variables to be reassigned.</li>
        <li>Variables declared with let can be reassigned to different values.</li>
        <img src="./assets/images/variablesLet1.jpg" alt="let variable 1">
        <li>let variables can be declared without assigning an initial value.</li>
        <li>In such cases, the variable is automatically initialized with the value undefined.</li>
        <li>The value of a price variable can be assigned later.</li>
        <img src="./assets/images/variablesLet2.jpg" alt="let variable 2">
      </ul>
    </section>

    <section>
      <h3>Const Variables</h3>
      <ul>
        <li>The const keyword was introduced in ES6 and is used to declare constant variables.</li>
        <img src="./assets/images/variablesLConst.jpg" alt="const variable">
        <li>const variables cannot be reassigned once they are assigned a value.</li>
        <li>Attempting to reassign a const variable will result in a TypeError.</li>
        <li>const variables must be assigned a value when declared.</li>
        <li>Attempting to declare a const variable without a value will result in a SyntaxError.</li>
        <li>Choose between let and const based on whether you'll need to reassign the variable later.</li>
        <li>Use let if you need to reassign the variable, and use const for variables that remain constant.</li>
      </ul>
    </section>

    <section>
      <h3>Mathematical Assignment</h3>
      <ul>
        <li>Mathematical assignment operators combine mathematical operations with variable assignment.</li>
        <img src="./assets/images/mathematicalAssignmentOperators1.jpg" alt="mathematical operator 1">
        <li>The += operator adds a value to the variable and assigns the result back to the variable.</li>
        <img src="./assets/images/mathematicalAssignmentOperators2.jpg" alt="mathematical operator 2">
        <li>Other mathematical assignment operators include -= (subtract and assign), *= (multiply and assign), and /=
          (divide and assign).</li>
        <img src="./assets/images/mathematicalAssignmentOperators3.jpg" alt="mathematical operator 3">
      </ul>
    </section>

    <section>
      <h3>Increment & Decrement Operators</h3>
      <ul>
        <li>The increment operator (++) increases the value of a variable by 1.</li>
        <li>The decrement operator (--) decreases the value of a variable by 1.</li>
        <img src="./assets/images/increment.jpg" alt="increment operator">
        <img src="./assets/images/decrement.jpg" alt="decrement operator">
        <li>The updated value of the variable is assigned as the new value of that variable.</li>
      </ul>
    </section>

    <section>
      <h3>String Concatenation with Variables</h3>
      <ul>
        <li>The + operator can be used to concatenate strings in JavaScript.</li>
        <img src="./assets/images/stringConcatenationWithVariables.jpg" alt="string concatenation with a variable">
        <li>The value of the variable myPet is concatenated with other strings.</li>
        <li>The + operator combines multiple strings into one.</li>
        <li>The resulting concatenated string can be logged or used in other operations.</li>
      </ul>
    </section>

    <section>
      <h3>String Interpolation</h3>
      <ul>
        <li>In ES6, we can use template literals to interpolate variables into strings.</li>
        <li>Template literals are enclosed by backticks ( ).</li>
        <img src="./assets/images/stringInterpolation.jpg" alt="string Interpolation">
        <li>Inside the template literal, we use ${} as a placeholder for the variable.</li>
        <li>The value of the variable myPet is inserted into the template literal.</li>
        <li>Template literals improve code readability and eliminate the need for escaping quotes.</li>
      </ul>
    </section>

    <section>
      <h3>typeof Operator</h3>
      <ul>
        <li>The typeof operator is used to check the data type of a value.</li>
        <li>The typeof operator returns a string representing the data type of the value.</li>
        <li>It can be used to check the data type of variables or expressions.</li>
        <li>Common data types returned by typeof are 'string', 'number', 'boolean', 'object', 'function', and
          'undefined'.</li>
        <img src="./assets/images/typeofOperator.jpg" alt="typeof operators">
      </ul>
    </section>

    <section>
      <h3>Review: Variables</h3>
      <ul>
        <li>Variables hold reusable data in a program and associate it with a name.</li>
        <li>Variables are stored in memory.</li>
        <li>The var keyword is used in pre-ES6 versions of JS.</li>
        <li>let is the preferred way to declare a variable when it can be reassigned, and const is the preferred way to
          declare a variable with a constant value.</li>
        <li>Variables that have not been initialized store the primitive data type undefined.</li>
        <li>Mathematical assignment operators make it easy to calculate a new value and assign it to the same variable.
        </li>
        <li>The + operator is used to concatenate strings including string values held in variables.</li>
        <li>In ES6, template literals use backticks ` and ${} to interpolate values into a string.</li>
        <li>The typeof keyword returns the data type (as a string) of a value.</li>
      </ul>
    </section>

    <h2>Conditional Statements</h2>

    <section>
      <h3>Introduction to Conditional Statements</h3>
      <ul>
        <li>Conditional statements are used to make decisions in code based on specific conditions.</li>
        <li>They mimic everyday decision-making processes where actions are taken based on circumstances.</li>
        <li>Conditional statements consist of if, else if, and else statements.</li>
        <li>Comparison operators are used to evaluate conditions and determine if they are true or false.</li>
        <li>Logical operators allow combining multiple conditions and creating complex conditionals.</li>
        <li>Values in JavaScript can be categorized as truthy or falsy based on their boolean evaluation.</li>
        <li>Ternary operators provide a concise way to write conditional expressions.</li>
        <li>The switch statement is another type of conditional statement used for multiple case scenarios.</li>
      </ul>
    </section>

    <section>
      <h3>if Statements</h3>
      <ul>
        <li>An if statement allows us to perform a task based on a condition.</li>
        <li>Syntax: if (condition) { // code block }</li>
        <li>The condition is placed inside parentheses ().</li>
        <li>If the condition evaluates to true, the code inside the block is executed.</li>
        <li>If the condition evaluates to false, the block is skipped.</li>
        <li>The code block is indicated by curly braces {}.</li>
        <img src="./assets/images/ifStatement.jpg" alt="if statement">
      </ul>
    </section>

    <section>
      <h3>if...else Statements</h3>
      <ul>
        <li>An if...else statement allows us to execute different blocks of code based on a condition.</li>
        <li>if (condition) {
          // code block to execute if the condition is true
          } else {
          // code block to execute if the condition is false
          }</li>
        <li>The condition is placed inside parentheses ().</li>
        <li>If the condition evaluates to true, the code block inside the if statement is executed.</li>
        <li>If the condition evaluates to false, the code block inside the else statement is executed.</li>
        <li>The code blocks are indicated by curly braces {}.</li>
        <li>An if...else statement is used to make binary decisions.</li>
        <img src="./assets/images/ifElseStatement.jpg" alt="if else statement">
        <li></li>
      </ul>
    </section>

    <section>
      <h3>Comparison Operators</h3>
      <ul>
        <li>Comparison operators are used in conditional statements to compare values.</li>
        <li>Common comparison operators include:</li>
        <li>Less than (<) </li>
        <li>Greater than (>) </li>
        <li> Less than or equal to (<=) </li>
        <li>Greater than or equal to (>=) </li>
        <li>Is equal to (===)</li>
        <li>Is not equal to (!==)</li>
        <li>Comparison operators compare the value on the left with the value on the right</li>
        <li>The result of a comparison is either true or false</li>
        <img src="./assets/images/comparisonOperators1.jpg" alt="comparison operator 1">
        <img src="./assets/images/comparisonOperators2.jpg" alt="comparison operator 2">
        <li>Comparison statements are like questions, where a "yes" answer evaluates to true and a "no" answer evaluates
          to false.</li>
        <li>Comparison statements consist of two values being compared and an operator separating them.</li>
      </ul>
    </section>

    <section>
      <h3>Logical Operators</h3>
      <ul>
        <li>Logical operators are used to work with boolean values in conditionals.</li>
        <li>There are three logical operators:</li>
        <li>The and operator (&&) checks if two conditions are true.</li>
        <li>The or operator (||) checks if at least one condition is true.</li>
        <li>The not operator (!) reverses the boolean value.</li>
        <img src="./assets/images/logicalOperators1.jpg" alt="logical AND operator">
        <img src="./assets/images/logicalOperators2.jpg" alt="logical OR operator">
        <img src="./assets/images/logicalOperators3.jpg" alt="logical NOT operator">
        <li>Logical operators help add more sophisticated logic to conditionals.</li>
      </ul>
    </section>

    <section>
      <h3>Truthy and Falsy</h3>
      <ul>
        <li>When evaluating non-boolean data types in a condition, they can be treated as truthy or falsy values.</li>
        <li>Truthy values: Any value that is not falsy (i.e., non-empty strings, numbers other than 0, arrays, objects,
          etc.).</li>
        <li>Falsy values:</li>
        <li>0</li>
        <li>Empty strings like "" or ''</li>
        <li>null</li>
        <li>undefined</li>
        <li>NaN (Not a Number)</li>
        <img src="./assets/images/truthyFalsy1.jpg" alt="truthy falsy 1">
        <li>The code block in the if statement will run because myVariable has a truthy value.</li>
        <img src="./assets/images/truthyFalsy2.jpg" alt="truthy falsy 2">
        <li>The condition evaluates to false because the value of numberOfApples is 0, which is a falsy value.</li>

      </ul>
    </section>

    <section>
      <h3>Truthy and Falsy Assignment</h3>
      <ul>
        <li>When assigning a value to a variable based on a condition, you can use truthy and falsy evaluations to
          simplify the code.</li>
        <img src="./assets/images/truthyFalsyAssignment1.jpg" alt="truthy falsy assignment 1">
        <img src="./assets/images/truthyFalsyAssignment2.jpg" alt="truthy falsy assignment 2">
        <li>The logical OR operator (||) checks the left-hand condition first.</li>
        <li>If the left-hand condition (username) is truthy, it assigns the value of username to defaultName.</li>
        <li>If the left-hand condition is falsy, it assigns the value 'Stranger' to defaultName.</li>
        <li>This approach is known as short-circuit evaluation.</li>
      </ul>
    </section>

    <section>
      <h3>Ternary Operator</h3>
      <ul>
        <li>Ternary operators provide a concise way to write conditional statements.</li>
        <li>Syntax: condition ? expression1 : expression2</li>
        <li>If the condition is true, expression1 is executed. If the condition is false, expression2 is executed.</li>
        <img src="./assets/images/ternaryOperator.jpg" alt="ternary operator">
        <li>The ternary operator can be used as a shorthand alternative to if...else statements for simple conditions
          that evaluate to true or false.</li>
      </ul>
    </section>

    <section>
      <h3>else...if Statements</h3>
      <ul>
        <li>The else if statement allows for additional conditions to be checked in an if...else statement.</li>
        <li>It is placed between the if statement and the else statement.</li>
        <li>The syntax of an else if statement is: else if (condition) { ... }</li>
        <li>Multiple else if statements can be added to create complex conditionals.</li>
        <li>The else if statements are evaluated in order from top to bottom.</li>
        <li>Once a condition evaluates to true, the corresponding block of code is executed and the rest of the
          conditions are skipped.</li>
        <li>If none of the conditions evaluate to true, the code in the else statement (if present) is executed.</li>
        <img src="./assets/images/elseIfStatements.jpg" alt="else if statement">
        <li>In the example above, the code inside the else if statement stopLight === 'yellow' is executed because it
          evaluates to true.</li>
      </ul>
    </section>

    <section>
      <h3>Switch Statements</h3>
      <ul>
        <li>The switch statement provides an alternative syntax for handling multiple conditions based on a single
          value.</li>
        <li>The syntax of a switch statement is:</li>
        <li>switch (expression) {
          case value1:
          // Code to be executed if expression matches value1
          break;
          case value2:
          // Code to be executed if expression matches value2
          break;
          // ...
          default:
          // Code to be executed if none of the cases match
          break;
          }</li>
        <li>The expression is evaluated and compared to the values specified in each case.</li>
        <li>If a case matches the expression, the corresponding code block is executed.</li>
        <li>The break keyword is used to exit the switch statement after a case is matched and executed.</li>
        <li>If none of the cases match the expression, the code in the default block is executed.</li>
        <li>Without break statements, all subsequent cases will be executed regardless of whether they match or not.
        </li>
        <li>The switch statement provides a more concise and readable way to handle multiple conditions compared to
          multiple else if statements.</li>
        <img src="./assets/images/switchKeyword.jpg" alt="switch keyword">
        <li>In the example above, the switch statement evaluates the value of groceryItem and executes the code block
          corresponding to the matching case. Since groceryItem is 'papaya', the code inside the 'papaya' case block is
          executed.</li>
      </ul>
    </section>

    <section>
      <h3>Review: Conditionals</h3>
      <ul>
        <li>An if statement checks a condition and will execute a task if that condition evaluates to true.</li>
        <li>if...else statements make binary decisions and execute different code blocks based on a provided condition.
        </li>
        <li>We can add more conditions using else if statements.</li>
        <li>Comparison operators, including <,>, <=,>=, ===, and !== can compare two values.</li>
        <li>The logical and operator, &&, or “and”, checks if both provided expressions are truthy.</li>
        <li>The logical operator ||, or “or”, checks if either provided expression is truthy.</li>
        <li>The bang operator, !, switches the truthiness and falsiness of a value.</li>
        <li>The ternary operator is shorthand to simplify concise if...else statements. </li>
        <li>A switch statement can be used to simplify the process of writing multiple else if statements. The break
          keyword stops the remaining cases from being checked and executed in a switch statement.</li>
      </ul>
    </section>

    <h2>Functions</h2>

    <section>
      <h3>What are Functions?</h3>
      <ul>
        <li>A function is a reusable block of code that performs a specific task.</li>
        <li>Steps to calculate the area of a rectangle:</li>
        <li>Measure the width of the rectangle.</li>
        <li>Measure the height of the rectangle.</li>
        <li>Multiply the width and height to get the area.</li>
        <li>A function allows us to group a block of code together to perform a specific task.</li>
        <li>Instead of rewriting the same code, we can create a function and reuse it whenever needed.</li>
        <li>A function is a reusable block of code that performs a specific task.</li>
        <li>Example: Calculating the area of a rectangle using a function:</li>
        <li>Define the function with a name, such as calculateArea.</li>
        <li>Pass the necessary parameters, such as width and height.</li>
        <li>Inside the function, multiply the width and height to calculate the area.</li>
        <li>Return the calculated area.</li>
        <li>Example:</li>
        <li>function calculateArea(width, height) {
          const area = width * height;
          console.log(area);
          }</li>
        <li>To execute or call a function, we use the function name followed by parentheses and any necessary arguments
          (values to be passed into the function).</li>
        <li>calculateArea(10, 6); // Output: 60</li>
        <li>Inside the function, the parameters act as variables that hold the values passed into the function.</li>
      </ul>
    </section>

    <section>
      <h3>Function Declarations</h3>
      <ul>
        <li>Function declaration is one way to create a function in JavaScript.</li>
        <li>A function declaration consists of the function keyword, followed by the name of the function and
          parentheses.</li>
        <li>The function body contains the block of statements that perform a specific task, enclosed in curly brackets.
        </li>
        <li>Function declarations bind a function to an identifier or name.</li>
        <li>Hoisting is a feature in JavaScript that allows access to function declarations before they are defined.
        </li>
        <li>Hoisting can be used to call a function before it is defined, but it is not considered good practice.</li>
      </ul>
    </section>

    <section>
      <h3>Calling a Function</h3>
      <ul>
        <li>To call a function, use the function name followed by parentheses.</li>
        <li>The code inside a function body executes only when the function is called.</li>
        <li>You can call the same function multiple times as needed.</li>
      </ul>
    </section>

    <section>
      <h3>Parameters and Arguments</h3>
      <ul>
        <li>Parameters allow functions to accept input(s) and use them to perform a task.</li>
        <li>Parameters are specified in the function declaration between parentheses.</li>
        <li>Inside the function body, parameters act like regular variables.</li>
        <li>When calling a function with parameters, values or variables can be passed as arguments.</li>
        <li>Arguments are specified in the parentheses when calling the function.</li>
        <li>The order of arguments should match the order of parameters in the function declaration.</li>
        <li>By using parameters, a function can be reused to perform the same task with different inputs.</li>
      </ul>
    </section>

    <section>
      <h3>Default Perameters</h3>
      <ul>
        <li>Default parameters allow parameters to have a predetermined value in case no argument is passed or the
          argument is undefined.</li>
        <li>Default parameters are specified using the = operator in the function declaration.</li>
        <li>When a function is called with an argument, the argument value overrides the default parameter value.</li>
        <li>When a function is called without an argument, the default parameter value is used.</li>
        <li>Default parameters are useful for handling situations when an argument is not provided to a function that
          expects one.</li>
      </ul>
    </section>

    <section>
      <h3>Return</h3>
      <ul>
        <li>The return statement is used in a function to pass back a value as the result of the function.</li>
        <li>When a function encounters a return statement, the execution of the function is stopped, and the value
          specified in the return statement is returned.</li>
        <li>If no value is specified in the return statement, the function will return undefined by default.</li>
        <li>The return statement can be used to exit the function early and prevent the execution of any code that
          follows it.</li>
        <li>Example:</li>
        <li>function rectangleArea(width, height) {
          if (width < 0 || height < 0) { return 'You need positive integers to calculate area!' ; } return width *
            height; }</li>
        <li>By using the return statement, we can capture the result of a function and use it later or assign it to a
          variable.</li>
      </ul>
    </section>

    <section>
      <h3>Helper Functions</h3>
      <ul>
        <li>Helper functions are functions that are called within another function to perform a specific task.</li>
        <li>They make the code easier to read and debug by dividing a complex task into smaller, more manageable parts.
        </li>
        <li>The return value of a helper function can be used as an input for another function.</li>
        <li>Helper functions can be defined separately and called within another function to perform a specific
          computation or task.</li>
        <li>Using helper functions allows for code modularity and reusability, as the same helper function can be used
          in multiple places.</li>
        <li>Helper functions help organize and structure code by separating different parts of logic into distinct
          functions.</li>
      </ul>
    </section>

    <section>
      <h3>Function Expressions</h3>
      <ul>
        <li>Function expressions are another way to define functions in JavaScript.</li>
        <li>They involve using the function keyword to create an anonymous function that is assigned to a variable.</li>
        <li>The function name is typically omitted in function expressions.</li>
        <li>Function expressions are often stored in variables to be referenced and invoked later.</li>
        <li>To declare a function expression, use the const keyword (preferred in ES6) or let keyword to declare a
          variable and assign it an anonymous function.</li>
        <li>The function body is defined inside curly braces after the parentheses that may contain parameters.</li>
        <li>Function expressions are invoked by using the variable name followed by parentheses and passing any required
          arguments.</li>
        <li>Unlike function declarations, function expressions are not hoisted, so they must be defined before they are
          called.</li>
      </ul>
    </section>

    <section>
      <h3>Arrow Functions</h3>
      <ul>
        <li>Arrow function syntax is a shorter way to write functions in JavaScript.</li>
        <li>It uses the "fat arrow" (=>) notation.</li>
        <li>Arrow functions remove the need to use the keyword "function".</li>
        <li>Parameters are specified within parentheses ().</li>
        <li>The function body is surrounded by curly braces {}.</li>
        <li>Return statements can be used to return a value from an arrow function.</li>
        <li>Arrow functions are commonly used in modern JavaScript code.</li>
        <li>It's important to be familiar with arrow function syntax when reading and writing JavaScript code.</li>
      </ul>
    </section>

    <section>
      <h3>Concise Body Arrow Functions</h3>
      <ul>
        <li>JavaScript allows for refactoring arrow function syntax into a more concise form called concise body.</li>
        <li>When a function takes a single parameter, the parentheses around the parameter can be omitted.</li>
        <li>When the function body consists of a single-line block, the curly braces {} and the return keyword can be
          removed.</li>
        <li>The result of the single-line block will be automatically returned.</li>
        <li>The concise body arrow function syntax helps to write shorter and more readable code.</li>
        <li>It's important to understand and recognize concise body arrow functions when working with JavaScript code.
        </li>
        <li>Example:</li>
        <li>const squareNum = (num) => {
          return num * num;
          };</li>
        <li>Can be: const squareNum = num => num * num;
        </li>
      </ul>
    </section>

    <section>
      <h3>Review: Functions</h3>
      <ul>
        <li>A function is a reusable block of code that groups together a sequence of statements to perform a specific
          task.</li>
        <li>A function declaration:</li>
        <li>function greet(name) {
          console.log(`Hello, ${name}!`);
          }

          greet('John');
        </li>
        <li>A parameter is a named variable inside a function’s block which will be assigned the value of the argument
          passed in when the function is invoked:</li>
        <li>function multiply(num1, num2) {
          return num1 * num2;
          }

          const result = multiply(5, 3);
          console.log(result);
        </li>
        <li>To call a function in your code:</li>
        <li>function sayHello() {
          console.log('Hello!');
          }

          sayHello();
        </li>
        <li>ES6 introduces new ways of handling arbitrary parameters through default parameters which allow us to assign
          a default value to a parameter in case no argument is passed into the function.
        </li>
        <li>To return a value from a function, we use a return statement.
        </li>
        <li>To define a function using function expressions:</li>
        <li>const square = function(num) {
          return num * num;
          };

          console.log(square(4));
        </li>
        <li>To define a function using arrow function notation:</li>
        <li>const double = (num) => {
          return num * 2;
          }

          console.log(double(5));
        </li>
        <li>Function definition can be made concise using concise arrow notation:</li>
        <li>const sum = (num1, num2) => num1 + num2;

          console.log(sum(3, 4));
        </li>
        <li>It’s good to be aware of the differences between function expressions, arrow functions, and function
          declarations. As you program more in JavaScript, you’ll see a wide variety of how these function types are
          used. </li>
      </ul>
    </section>

    <h2>Scope</h2>

    <section>
      <h3>Scope Introduction</h3>
      <ul>
        <li>Scope determines the accessibility or visibility of variables in a program.</li>
        <li>There are different scopes in JavaScript, including global scope, function scope, and block scope.</li>
        <li>Variables defined in the global scope are accessible from anywhere in the program.</li>
        <li>Function scope refers to the variables that are accessible within a specific function.</li>
        <li>Block scope is a narrower scope defined by blocks of code, such as those inside if statements or loops.</li>
        <li>Variables defined in a higher scope can be accessed by inner scopes, but not vice versa.</li>
        <li>The concept of scope helps in organizing and managing variables and prevents naming conflicts.</li>
        <li>Understanding scope is crucial for writing maintainable and bug-free code.</li>
      </ul>
    </section>

    <section>
      <h3>Blocks & Scope</h3>
      <ul>
        <li>Blocks are sections of code enclosed within curly braces {}.</li>
        <li>Blocks help group one or more statements together and provide structural organization in the code.</li>
        <li>Functions and if statements are examples of blocks.</li>
        <li>Variables declared inside a block are scoped to that block, meaning they are only accessible within that
          block.</li>
        <li>Scoping of variables within blocks helps prevent naming conflicts and provides encapsulation.</li>
        <li>Variables declared in an outer block are not accessible in inner blocks, but variables declared in inner
          blocks can access variables declared in outer blocks.</li>
        <li>Understanding blocks and scoping is important for managing variable visibility and controlling the flow of
          execution in your code.</li>
      </ul>
    </section>

    <section>
      <h3>Global Scope</h3>
      <ul>
        <li>Scope refers to the context in which variables are declared.</li>
        <li>Variables can exist either outside of or within blocks.</li>
        <li>Global scope refers to variables declared outside of blocks.</li>
        <li>Global variables can be accessed by any code in the program, including code in blocks.</li>
        <li>Global variables are not bound inside a block.</li>
        <li>Example:</li>
        <li>const color = 'blue';

          const returnSkyColor = () => {
          return color; // blue
          };

          console.log(returnSkyColor()); // blue</li>
        <li>The console.log(returnSkyColor()) statement outputs "blue" because the color variable can be accessed within
          the function block.</li>
      </ul>
    </section>

    <section>
      <h3>Block Scope</h3>
      <ul>
        <li>Block scope refers to the scope of variables defined inside a block, which is only accessible within that
          block.</li>
        <li>Variables declared with block scope are known as local variables.</li>
        <li>Local variables are only available to the code within the same block.</li>
        <li>Example:</li>
        <li>const logSkyColor = () => {
          let color = 'blue';
          console.log(color); // Prints "blue"
          };

          logSkyColor(); // Prints "blue"
          console.log(color); // throws a ReferenceError</li>
        <li>Inside the logSkyColor function, the color variable is defined and can only be accessed within the function
          block.</li>
        <li>Trying to access the color variable outside the function block will throw a ReferenceError.</li>
      </ul>
    </section>

    <section>
      <h3>Scope Polution</h3>
      <ul>
        <li>Having too many global variables can cause problems in a program</li>
        <li>Global variables are accessible from anywhere in the program and remain there until the program finishes
        </li>
        <li>Scope pollution makes it difficult to keep track of different variables and can cause unexpected behavior in
          the code</li>
        <li>Best practice is to avoid defining variables in the global scope</li>
        <li>let num = 50;

          const logNum = () => {
          num = 100; // Take note of this line of code
          console.log(num);
          };

          logNum(); // Prints 100
          console.log(num); // Prints 100</li>
        <li>Inside the function body of logNum(), we want to declare a new variable but forgot to use the let keyword.
        </li>
        <li>When we call logNum(), num gets reassigned to 100.</li>
        <li>The reassignment inside logNum() affects the global variable num.</li>
        <li>Even though the reassignment is allowed and we won’t get an error, if we decided to use num later, we’ll
          unknowingly use the new value of num.</li>
      </ul>
    </section>

    <section>
      <h3>Practice Good Scoping</h3>
      <ul>
        <li>Follow best practices for scoping variables tightly using block scope</li>
        <li>Benefits of tightly scoping variables:</li>
        <li>Improved code legibility and organization</li>
        <li>Better code understanding and clarity</li>
        <li>Easier code maintenance and modularity</li>
        <li>Memory-saving as variables cease to exist after the block finishes running</li>
        <li>Example of block scope within an if block:</li>
        <li>const logSkyColor = () => {
          const dusk = true;
          let color = 'blue';
          if (dusk) {
          let color = 'pink';
          console.log(color); // Prints "pink"
          }
          console.log(color); // Prints "blue"
          };

          console.log(color); // throws a ReferenceError</li>
        <li>Variables declared inside the block are only accessible within the block</li>
        <li>Reusing the same variable name inside the block can lead to namespace pollution</li>
        <li>It's recommended to avoid defining variables in the global scope and use block scope instead</li>
        <li>Block scope is a powerful tool in JavaScript, since it allows us to define variables with precision, and not
          pollute the global namespace. If a variable does not need to exist outside a block— it shouldn’t!</li>
      </ul>
    </section>

    <section>
      <h3>Review: Scope</h3>
      <ul>
        <li>Scope refers to where variables can be accessed throughout the program, and is determined by where and how
          they are declared.</li>
        <li>Blocks are statements that exist within curly braces {}. </li>
        <li>Global scope refers to the context within which variables are accessible to every part of the program.</li>
        <li>Global variables are variables that exist within global scope.</li>
        <li>Block scope refers to the context within which variables are accessible only within the block they are
          defined.</li>
        <li>Local variables are variables that exist within block scope.</li>
        <li>Global namespace is the space in our code that contains globally scoped information.</li>
        <li>Scope pollution is when too many variables exist in a namespace or variable names are reused.</li>
        <li></li>
      </ul>
    </section>

    <h2>Arrays</h2>

    <section>
      <h3>Arrays Introduction</h3>
      <ul>
        <li>Arrays are used to organize and store data in JavaScript.</li>
        <li>Arrays are similar to lists in real life and can store any data types.</li>
        <li>Array elements are ordered and have a numbered position.</li>
        <li>Example of creating an array:</li>
        <li>Syntax: let arrayName = [element1, element2, element3, ...];</li>
        <li>Example: let newYearsResolutions = ['Keep a journal', 'Take a falconry class', 'Learn to juggle'];</li>
        <li>Arrays can be used to store various concepts or items.</li>
        <li>Example: let concepts = ['creating arrays', 'array structures', 'array manipulation'];</li>
      </ul>
    </section>

    <section>
      <h3></h3>
      <ul>
        <li>Create an Array</li>
        <li>Use an array literal by wrapping items in square brackets [].</li>
        <li>Each item inside the array is called an element.</li>
        <li>Elements can be of any data type.</li>
        <li>Elements are separated by commas.</li>
        <li>The array can be saved to a variable.</li>
        <li>const hobbies = ['gaming', 'cubing', 'coding']</li>
      </ul>
    </section>

    <section>
      <h3>Accessing Elements</h3>
      <ul>
        <li>Each element in an array has an index, starting from 0.</li>
        <li>Use bracket notation, [] with the index, to access elements in an array.</li>
        <li>Arrays in JavaScript are zero-indexed.</li>
        <li>You can also access individual characters in a string using bracket notation and the index.</li>
        <li>Example:</li>
        <li>const hello = 'Hello World';
          console.log(hello[6]);
          // Output: W</li>
      </ul>
    </section>

    <section>
      <h3>Updating Elements</h3>
      <ul>
        <li>Once you have access to an element in an array, you can update its value.</li>
        <li>Use the assignment operator (=) to assign a new value to the element.</li>
        <li>Specify the index of the element you want to update and assign the new value to it.</li>
        <li>The updated value will replace the existing value at that index in the array.</li>
        <li>let seasons = ['Winter', 'Spring', 'Summer', 'Fall'];

          seasons[3] = 'Autumn';</li>
        <li>console.log(seasons);
          //Output: ['Winter', 'Spring', 'Summer', 'Autumn']</li>
      </ul>
    </section>

    <section>
      <h3>Arrays with let and const</h3>
      <ul>
        <li>Variables declared with let can be reassigned, including arrays.</li>
        <li>Elements in an array declared with const can be changed or mutated.</li>
        <li>However, a const array itself cannot be reassigned to a new array or a different value.</li>
      </ul>
    </section>

    <section>
      <h3>The .length Property</h3>
      <ul>
        <li>The .length property is a built-in property of arrays that returns the number of items in the array.</li>
        <li>It is accessed using dot notation, like array.length.</li>
        <li>It can be used to determine the size or length of an array.</li>
        <li>Example: const array = [1, 2, 3]; console.log(array.length); // Output: 3</li>
      </ul>
    </section>

    <section>
      <h3>The .push() method</h3>
      <ul>
        <li>The .push() method is a built-in method in JavaScript that allows us to add items to the end of an array.
        </li>
        <li>It is called using dot notation on an array, like array.push(item1, item2).</li>
        <li>It can take one or more arguments, which are the elements to be added to the array.</li>
        <li>The .push() method mutates the original array by adding the new elements to its end.</li>
        <li>Example: const array = [1, 2, 3]; array.push(4, 5);</li>
        <li>console.log(array); // Output: [1, 2, 3, 4, 5]</li>
      </ul>
    </section>

    <section>
      <h3>The .pop() method</h3>
      <ul>
        <li>The .pop() method is a built-in method in JavaScript that removes the last item from an array.</li>
        <li>It is called using dot notation on an array, like array.pop().</li>
        <li>It does not take any arguments.</li>
        <li>The .pop() method mutates the original array by removing the last element.</li>
        <li>It returns the value of the removed element.</li>
        <li>Example:</li>
        <li>const array = [1, 2, 3];
          const removed = array.pop();
        </li>
        <li>console.log(array); // Output: [1, 2]
          console.log(removed); // Output: 3</li>
        <li></li>
      </ul>
    </section>

    <section>
      <h3>Arrays & Functions</h3>
      <ul>
        <li>Arrays in JavaScript are mutable, meaning they can be changed.</li>
        <li>When an array is passed into a function and mutated inside the function, the changes are maintained outside
          the function as well.</li>
        <li>const flowers = ['peony', 'daffodil', 'marigold'];

          function addFlower(arr) {
          arr.push('lily');
          }
        </li>
        <li>addFlower(flowers);</li>
        <li>console.log(flowers); // Output: ['peony', 'daffodil', 'marigold', 'lily']</li>
        <li>In the given example, the addFlower() function takes an array parameter arr and uses the .push() method to
          add a 'lily' element to arr.</li>
        <li>The addFlower() function is called with an argument flowers, which executes the code inside the function.
        </li>
        <li>After calling addFlower(flowers), the value of the flowers array now includes the 'lily' element. The array
          was mutated.</li>
        <li>This behavior is known as pass-by-reference, as the function receives a reference to the memory location
          where the array is stored and modifies that memory.</li>
      </ul>
    </section>

    <section>
      <h3>Nested Arrays</h3>
      <ul>
        <li>Arrays can store other arrays, forming a nested array structure.</li>
        <li>A nested array is an array that is an element of another array.</li>
        <li>To access nested arrays, we use bracket notation with the index value.</li>
        <li>Example: const nestedArr = [[1], [2, 3]];</li>
        <li>nestedArr[1] accesses the element at index 1, which is the array [2, 3].</li>
        <li>To access elements within the nested array, we can chain additional bracket notation with index values.</li>
        <li>Example: nestedArr[1][0] accesses the first element of the nested array and returns the value 2.</li>
      </ul>
    </section>

    <section>
      <h3>Review: Arrays</h3>
      <ul>
        <li>Arrays are lists that store data in JavaScript. </li>
        <li>Arrays are created with brackets [].</li>
        <li>Each item inside of an array is at a numbered position, or index, starting at 0. </li>
        <li>We can access one item in an array using its index, with syntax like: myArray[0].</li>
        <li>We can also change an item in an array using its index, with syntax like myArray[0] = 'new string'; </li>
        <li>Arrays have a length property, which allows you to see how many items are in an array.</li>
        <li>Arrays have their own methods, including .push() and .pop(), which add and remove items from an array,
          respectively.</li>
        <li>Arrays have many methods that perform different tasks, such as .slice() and .shift(), you can find
          documentation at the Mozilla Developer Network website. </li>
        <li>Some built-in methods are mutating, meaning the method will change the array, while others are not mutating.
          You can always check the documentation. </li>
        <li>Variables that contain arrays can be declared with let or const. Even when declared with const, arrays are
          still mutable. However, a variable declared with const cannot be reassigned. </li>
        <li>Arrays mutated inside of a function will keep that change even outside the function. </li>
        <li>Arrays can be nested inside other arrays. </li>
        <li>To access elements in nested arrays chain indices using bracket notation. </li>
        <li></li>
        <li></li>
      </ul>
    </section>

    <h2>Loops</h2>

    <section>
      <h3>Loops Introduction</h3>
      <ul>
        <li>A loop is a programming tool that repeats a set of instructions until a specified condition, called a
          stopping condition, is met.</li>
        <li>Loops allow us to automate processes and make our code more efficient.</li>
        <li>The term "iterate" is often used to describe the act of repeating a set of instructions in a loop.</li>
        <li>Loops are commonly used when a task or process needs to be repeated multiple times in a row.</li>
        <li>By using loops, we can create scalable and manageable programs.</li>
      </ul>
    </section>

    <section>
      <h3>The For Loop</h3>
      <ul>
        <li>A for loop is a way to repeat a block of code by specifying an iterator variable, a stopping condition, and
          an iteration statement.</li>
        <li>The for loop syntax consists of three expressions separated by semicolons inside the parentheses:
          initialization, stopping condition, and iteration statement.</li>
        <li>The iterator variable is typically used to keep track of the loop iteration and is initialized before the
          loop starts.</li>
        <li>The stopping condition is evaluated before each iteration, and if it's true, the code block inside the loop
          is executed. If it's false, the loop stops.</li>
        <li>The iteration statement is executed after each iteration and is used to update the iterator variable.</li>
        <li>The code block enclosed in curly braces is the code that will be repeated in each iteration.</li>
        <li>The for loop allows us to write code that repeats a certain number of times based on the specified
          conditions.</li>
        <li>The iterator variable can have any name, but it's recommended to use a descriptive name for clarity.</li>
        <li>The for loop provides an efficient and concise way to automate repetitive tasks in our code.</li>
        <li>Example:</li>
        <li>for (let counter = 0; counter < 4; counter++) { console.log(counter); }</li>
      </ul>
    </section>

    <section>
      <h3>Looping in Reverse</h3>
      <ul>
        <li>To make a for loop run in reverse, we need to make some modifications to the expressions.</li>
        <li>Set the iterator variable to the highest desired value in the initialization expression.</li>
        <li>Set the stopping condition for when the iterator variable is less than the desired amount.</li>
        <li>Decrease the iterator variable in intervals after each iteration.</li>
        <li>By making these modifications, we can make the loop count down instead of counting up.</li>
        <li>Be cautious of creating infinite loops, where the stopping condition is not met and the program gets stuck.
          If this happens, refresh the page and fix the loop code.</li>
      </ul>
    </section>

    <section>
      <h3>Looping Through Arrays</h3>
      <ul>
        <li>for loops are useful for iterating over data structures like arrays.</li>
        <li>To loop through each element in an array, use the array's .length property in the loop's condition.</li>
        <li>Example:</li>
        <li>const animals = ['Grizzly Bear', 'Sloth', 'Sea Lion'];
          for (let i = 0; i < animals.length; i++) { console.log(animals[i]); } </li>
        <li>The loop iterates through the array, and the iterator variable i represents the index of each element.</li>
        <li>The loop stops when i is no longer less than animals.length.</li>
        <li>Arrays are zero-indexed, so the last element's index is length - 1.Using for loops makes it easier to work
          with elements in arrays.</li>
        <li>Using for loops makes it easier to work with elements in arrays.</li>
      </ul>
    </section>

    <section>
      <h3>Nested Loops</h3>
      <ul>
        <li>Nested loops are loops that are placed inside another loop.</li>
        <li>One use of nested loops is to compare elements in two arrays.</li>
        <li>Example:</li>
        <li>const myArray = [6, 19, 20];
          const yourArray = [19, 81, 2];</li>
        <li>for (let i = 0; i < myArray.length; i++) {</li>
        <li>for (let j = 0; j < yourArray.length; j++) {</li>
        <li>if (myArray[i] === yourArray[j]) {</li>
        <li>console.log('Both arrays have the number: ' + yourArray[j]);}
          }
          }</li>
        <li>In the nested loop, the inner loop runs completely for each iteration of the outer loop.</li>
        <li>The inner loop compares the current element from the outer array (myArray[i]) with each element in the inner
          array (yourArray[j]).</li>
        <li>When a match is found, a string is printed to the console.</li>
        <li>Nested loops are useful for performing comparisons and operations involving multiple arrays or data
          structures.</li>
      </ul>
    </section>

    <section>
      <h3>The While Loop</h3>
      <ul>
        <li>While loops are a type of loop in JavaScript.</li>
        <li>They are used when we don't know in advance how many times the loop should run.</li>
        <li>A while loop has a stopping condition that is evaluated before each round of the loop.</li>
        <li>If the condition evaluates to true, the loop's code block will run, and if it evaluates to false, the loop
          will stop.</li>
        <li>It is important to include code inside the loop's block that updates the variables involved in the stopping
          condition.</li>
        <li>Without proper updates, the loop can result in an infinite loop, which can freeze the computer.</li>
        <li>While loops are useful in situations where the number of iterations is not predetermined.</li>
        <li>They allow the code to continue executing as long as the stopping condition remains true.</li>
        <li>While loops are analogous to eating, where you continue eating while you're hungry without knowing the exact
          number of bites needed to become full.</li>
        <li>Example:</li>
        <li>let counterTwo = 1;
          while (counterTwo < 4) { console.log(counterTwo); counterTwo++; }</li>
      </ul>
    </section>

    <section>
      <h3>Do..While Statements</h3>
      <ul>
        <li>The do...while statement is used when you want a piece of code to run at least once and then continue
          running based on a specified condition.</li>
        <li>The syntax for a do...while statement is do { // code block } while (condition);.</li>
        <li>The code block inside the do keyword is executed once before the condition is evaluated.</li>
        <li>If the condition is true, the code block will execute again. The loop continues until the condition
          evaluates to false.</li>
        <li>The do...while loop is different from the while loop because it always runs at least once, regardless of the
          condition.</li>
        <li>In contrast, the while loop may not run at all if the condition is false from the beginning.</li>
        <li>It's important to ensure that the condition will eventually become false to avoid an infinite loop.</li>
        <li>Example:</li>
        <li>let countString = '';
          let i = 0;</li>
        <li>do {
          countString = countString + i;
          i++;
          } while (i < 5);</li>
      </ul>
    </section>

    <section>
      <h3>The Break Keyword</h3>
      <ul>
        <li>The break keyword is used to exit a loop prematurely from within its block.</li>
        <li>When encountered, the break statement immediately terminates the loop and continues executing the code
          outside of the loop.</li>
        <li>It is useful when you want to stop a loop from continuing to execute even if the original stopping condition
          is not met.</li>
        <li>The break statement can be used in loops such as for, while, and do...while.</li>
        <li>It allows you to add additional test conditions inside the loop and exit the loop when those conditions are
          met.</li>
        <li>The use of break statements is particularly helpful when working with large data structures or when you want
          to stop the loop based on specific conditions.</li>
        <li>for (let i = 0; i < 99; i++) { if (i> 2 ) {
            break;
            }
            console.log('Banana.');
            }</li>
      </ul>
    </section>

    <section>
      <h3>Review: Loops</h3>
      <ul>
        <li>Loops perform repetitive actions so we don’t have to code that process manually every time. </li>
        <li>How to write for loops with an iterator variable that increments or decrements</li>
        <li>How to use a for loop to iterate through an array</li>
        <li>A nested for loop is a loop inside another loop</li>
        <li>while loops allow for different types of stopping conditions</li>
        <li>Stopping conditions are crucial for avoiding infinite loops.</li>
        <li>do...while loops run code at least once— only checking the stopping condition after the first execution</li>
        <li>The break keyword allows programs to leave a loop during the execution of its block</li>
      </ul>
    </section>

    <h2>Higher-Order Functions</h2>

    <section>
      <h3>Higher-Order Functions Introduction</h3>
      <ul>
        <li>Higher-order functions are functions that accept other functions as arguments and/or return functions as
          output.</li>
        <li>They allow for building abstractions on top of other abstractions in programming.</li>
        <li>Functions in programming are similar to familiar subroutines in everyday language, allowing us to
          communicate complex concepts concisely.</li>
        <li>Functions help code to be reuseable and improve the readability of programs.</li>
        <li>Higher-order functions can be used to create powerful and flexible code structures.</li>
        <li>They enable us to pass behavior as a function, making our code more modular and adaptable.</li>
        <li>Examples of higher-order functions include map(), filter(), and reduce().</li>
      </ul>
    </section>

    <section>
      <h3>Functions as Data</h3>
      <ul>
        <li>JavaScript functions can be assigned to variables and treated like any other data type.</li>
        <li>They can be reassigned to new variables, allowing for shorter and more readable code.</li>
        <li>Assigning a function to a variable creates a reference to the original function, not the result of invoking
          it.</li>
        <li>Functions are first-class objects in JavaScript, meaning they can have properties and methods.</li>
        <li>Properties of functions include .length and .name, while methods include .toString().</li>
        <li>Functions can be invoked like any other data type, but they can also be manipulated and passed around as
          values.</li>
        <li>Treating functions as data enables higher-order functions and other advanced programming techniques.</li>
      </ul>
    </section>

    <section>
      <h3>Functions as Parameters</h3>
      <ul>
        <li>Functions can accept other functions as parameters.</li>
        <li>Functions that accept other functions as parameters are called higher-order functions.</li>
        <li>The functions passed as parameters are called callback functions.</li>
        <li>Callback functions are invoked during the execution of the higher-order function.</li>
        <li>When passing a callback function as a parameter, we do not invoke it by adding parentheses.</li>
        <li>The callback function is referenced by its name without parentheses.</li>
        <li>Higher-order functions can use the callback function by invoking it inside their body.</li>
        <li>Callback functions can be named functions or anonymous functions.</li>
        <li>Anonymous functions are functions without a name.</li>
      </ul>
    </section>

    <section>
      <h3>Review: Higher-Order Functions</h3>
      <ul>
        <li>Abstraction allows us to write complicated code in a way that’s easy to reuse, debug, and understand for
          human readers.
        </li>
        <li>We can work with functions the same way we work with any other type of data, including reassigning them to
          new variables.
        </li>
        <li>JavaScript functions are first-class objects, so they have properties and methods like any other object.
        </li>
        <li>Functions can be passed into other functions as parameters.
        </li>
        <li>A higher-order function is a function that either accepts functions as parameters, returns a function, or
          both.
        </li>
      </ul>
    </section>

    <h2>Iterators</h2>

    <section>
      <h3>Introduction to Iterators</h3>
      <ul>
        <li>Iterators are built-in array methods in JavaScript used to loop through arrays.</li>
        <li>They are also called iteration methods.</li>
        <li>Iterators manipulate array elements and return values.</li>
        <li>Iterators provide a more convenient and readable way to iterate over arrays compared to using a for loop.
        </li>
      </ul>
    </section>

    <section>
      <h3>The .forEach() Method</h3>
      <ul>
        <li>The .forEach() method is an iteration method used to loop through each element of an array.</li>
        <li>It takes a callback function as an argument.</li>
        <li>The callback function is executed for each element of the array, with the current element passed as an
          argument.</li>
        <li>The return value of .forEach() is always undefined.</li>
        <li>Callback functions can be defined using arrow function syntax or regular function syntax.</li>
        <li>It's a matter of preference which syntax to use for the callback function.</li>
      </ul>
    </section>

    <section>
      <h3>The .map() Method</h3>
      <ul>
        <li>The .map() method is an iteration method used to create a new array based on an existing array.</li>
        <li>It takes a callback function as an argument.</li>
        <li>The callback function is executed for each element of the array, with the current element passed as an
          argument.</li>
        <li>The return value of the callback function is added to a new array.</li>
        <li>The .map() method returns the new array.</li>
        <li>The original array is not modified.</li>
        <li>The new array can have a different length than the original array.</li>
        <li>The elements of the new array are determined by the return values of the callback function.</li>
      </ul>
    </section>

    <section>
      <h3>The .filter() Method</h3>
      <ul>
        <li>The .filter() method is an iteration method used to create a new array by filtering elements from an
          existing array.</li>
        <li>It takes a callback function as an argument.</li>
        <li>The callback function is executed for each element of the array, with the current element passed as an
          argument.</li>
        <li>The callback function should return true or false based on a condition.</li>
        <li>Elements that cause the callback function to return true are added to the new array.</li>
        <li>The .filter() method returns the new array.</li>
        <li>The original array is not modified.</li>
        <li>The new array may have a different length than the original array.</li>
        <li>The elements of the new array are determined by the return values of the callback function.</li>
      </ul>
    </section>

    <section>
      <h3>The .findIndex() Method</h3>
      <ul>
        <li>The .findIndex() method is an iteration method used to find the index of the first element that satisfies a
          given condition in an array.</li>
        <li>It takes a callback function as an argument.</li>
        <li>The callback function is executed for each element of the array, with the current element passed as an
          argument.</li>
        <li>The callback function should return true or false based on a condition.</li>
        <li>The .findIndex() method returns the index of the first element that evaluates to true in the callback
          function.</li>
        <li>If no element satisfies the condition, .findIndex() returns -1.</li>
        <li>The original array is not modified.</li>
        <li>The index returned corresponds to the first occurrence of the element that meets the condition.</li>
      </ul>
    </section>

    <section>
      <h3>The .reduce() Method</h3>
      <ul>
        <li>The .reduce() method is used to iterate through the elements of an array and return a single value.</li>
        <li>It takes a callback function as an argument, which has two parameters: accumulator and currentValue.</li>
        <li>The accumulator holds the accumulated value during the iteration process.</li>
        <li>The currentValue represents the current element being processed in the array.</li>
        <li>The .reduce() method iterates through the array, using the return value of the callback function as the
          accumulator for the next iteration.</li>
        <li>The initial value of the accumulator is the value of the first element in the array.</li>
        <li>After each iteration, the return value of the callback function is added to the accumulator.</li>
        <li>The process continues until all elements in the array have been processed.</li>
        <li>The final value of the accumulator is returned as the result of the .reduce() method.</li>
        <li>If an initial value for the accumulator is provided as a second argument to .reduce(), it will be used
          instead of the first element of the array.</li>
        <li>The .reduce() method can be useful for tasks such as summing the values in an array or performing other
          cumulative calculations.</li>
      </ul>
    </section>

    <section>
      <h3>Review: Iterators</h3>
      <ul>
        <li>.forEach() is used to execute the same code on every element in an array but does not change the array and
          returns undefined. </li>
        <li>.map() executes the same code on every element in an array and returns a new array with the updated
          elements. </li>
        <li>.filter() checks every element in an array to see if it meets certain criteria and returns a new array with
          the elements that return truthy for the criteria. </li>
        <li>.findIndex() returns the index of the first element of an array that satisfies a condition in the callback
          function. It returns -1 if none of the elements in the array satisfies the condition. </li>
        <li>.reduce() iterates through an array and takes the values of the elements and returns a single value. </li>
        <li>All iterator methods take a callback function, which can be a pre-defined function, a function expression,
          or an arrow function.</li>
        <li></li>
        <li></li>
        <li></li>
      </ul>
    </section>

    <h2>Objects</h2>

    <section>
      <h3>Introduction to Objects</h3>
      <ul>
        <li>Objects are a fundamental structure in JavaScript programming.</li>
        <li>JavaScript heavily relies on objects, and many components of the language are objects or can behave like
          objects.</li>
        <li>There are seven fundamental data types in JavaScript, including six primitive data types and objects.</li>
        <li>Objects provide more complex possibilities compared to primitive data types and allow us to model real-world
          things and build data structures.</li>
        <li>JavaScript objects are containers that store related data and functionality.</li>
        <li>Despite their seemingly simple task, objects are powerful and widely used in JavaScript programming.</li>
        <li>Understanding the mechanics of objects enables us to create our own objects and leverage their capabilities.
        </li>
      </ul>
    </section>

    <section>
      <h3>Creating Object Literals</h3>
      <ul>
        <li>Objects can be assigned to variables using object literals, denoted by curly braces {}.</li>
        <li>Example:</li>
        <li>let spaceship = {};</li>
        <li>Object literals allow us to organize data into key-value pairs.</li>
        <li>Keys in object literals are like variable names that point to a value.</li>
        <li>Keys can be of any data type, including functions or other objects.</li>
        <li>Key-value pairs are written as key: value, separated by commas.</li>
        <li>Keys are typically strings, but when they don't have special characters, quotation marks can be omitted.
        </li>
        <li>Example:</li>
        <li>let spaceship = { 'Fuel Type': 'diesel', color: 'silver' } defines an object with two properties:
          'Fuel Type' and color.</li>
      </ul>
    </section>

    <section>
      <h3>Accessing Properties</h3>
      <ul>
        <li>There are two ways to access an object's property.</li>
        <li>The first way is using dot notation: objectName.propertyName.</li>
        <li>Dot notation is used to access properties and methods of objects and data instances.</li>
        <li>Example: 'hello'.length returns the length of the string, which is 5.</li>
        <li>To access a property using dot notation, we write the object's name, followed by a dot (.), and then the
          property name.</li>
        <li>Example:</li>
        <li>let spaceship = {
          homePlanet: 'Earth',
          color: 'silver'
          };
          spaceship.homePlanet; // Returns 'Earth'
          spaceship.color; // Returns 'silver'
        </li>
        <li>If we try to access a property that does not exist on the object, undefined will be returned.</li>
        <li>Example: spaceship.favoriteIcecream returns undefined.</li>
      </ul>
    </section>

    <section>
      <h3>Bracket Notation</h3>
      <ul>
        <li>The second way to access an object's property is by using bracket notation: objectName['propertyName'].</li>
        <li>Bracket notation is used when accessing keys that have numbers, spaces, or special characters in them.</li>
        <li>To access an object's property using bracket notation, we pass the property name (key) as a string inside
          the brackets.</li>
        <li>Example:</li>
        <li>let spaceship = {
          'Fuel Type': 'Turbo Fuel',
          'Active Duty': true,
          homePlanet: 'Earth',
          numCrew: 5
          };
          spaceship['Active Duty']; // Returns true
          spaceship['Fuel Type']; // Returns 'Turbo Fuel'
          spaceship['numCrew']; // Returns 5
          spaceship['!!!!!!!!!!!!!!!']; // Returns undefined
        </li>
        <li>Bracket notation also allows us to use a variable inside the brackets to dynamically select the keys of an
          object.</li>
        <li>Example:</li>
        <li>let returnAnyProp = (objectName, propName) => objectName[propName];
          returnAnyProp(spaceship, 'homePlanet'); // Returns 'Earth'
        </li>
        <li>Using dot notation (objectName.propName) in this case would look for a key of 'propName' on the object
          instead of using the value of the propName parameter.</li>
      </ul>
    </section>

    <section>
      <h3>Property Assignment</h3>
      <ul>
        <li>Objects are mutable, meaning we can update them after creation.</li>
        <li>Property assignment can be done using dot notation (.) or bracket notation ([]), along with the assignment
          operator (=).</li>
        <li>If the property already exists on the object, the assigned value will replace the previous value.</li>
        <li>If there is no property with the given name, a new property will be added to the object.</li>
        <li>It is possible to mutate an object declared with const by adding new properties or changing existing ones,
          although the variable itself cannot be reassigned.</li>
        <li>Example:</li>
        <li>const spaceship = {type: 'shuttle'};
          spaceship.type = 'alien'; // Changes the value of the type property
          spaceship.speed = 'Mach 5'; // Creates a new key of 'speed' with a value of 'Mach 5'
        </li>
        <li>Properties can be deleted from an object using the delete operator.</li>
        <li>Example:</li>
        <li>const spaceship = {
          'Fuel Type': 'Turbo Fuel',
          homePlanet: 'Earth',
          mission: 'Explore the universe'
          };
          delete spaceship.mission; // Removes the mission property
        </li>
      </ul>
    </section>

    <section>
      <h3>Methods</h3>
      <ul>
        <li>Methods are functions that are stored as properties of objects.</li>
        <li>A property is what an object has, while a method is what an object does.</li>
        <li>Global objects in JavaScript, such as console and Math, have methods like .log() and .floor().</li>
        <li>Methods can be included in object literals by creating key-value pairs where the key is the method's name
          and the value is a function expression.</li>
        <li>Prior to ES6, the method syntax included the function keyword: methodName: function() { }.</li>
        <li>In ES6, a shorter syntax is available for defining methods inside object literals: methodName () { }.</li>
        <li>Example:</li>
        <li>const alienShip = {
          invade () {
          console.log('Hello! We have come to dominate your planet. Instead of Earth, it shall be called New Xaculon.')
          }
          };</li>
        <li>Object methods are invoked by using the object's name followed by the dot operator, the method name, and
          parentheses.</li>
        <li>Example:</li>
        <li>const alienShip = {
          invade: function() {
          console.log('Hello! We have come to dominate your planet. Instead of Earth, it shall be called New Xaculon.');
          }
          };

          alienShip.invade(); // Prints 'Hello! We have come to dominate your planet. Instead of Earth, it shall be
          called New Xaculon.'
        </li>
      </ul>
    </section>

    <section>
      <h3>Nested Objects</h3>
      <ul>
        <li>Objects can be nested within other objects, creating a hierarchy of properties.</li>
        <li>Nested objects allow for organizing and structuring complex data.</li>
        <li>Each level of nesting can have its own properties and methods.</li>
        <li>Accessing nested properties involves chaining operators to navigate through the object hierarchy.</li>
        <li>To access a nested property, use dot notation or bracket notation for each level of nesting.</li>
      </ul>
    </section>

    <section>
      <h3>Pass by Reference</h3>
      <ul>
        <li>Objects are passed by reference in JavaScript.</li>
        <li>When an object is passed into a function as an argument, the parameter inside the function points to the
          same memory location as the original object.</li>
        <li>Modifying properties of the object inside the function will permanently change the object.</li>
        <li>Reassigning the parameter inside the function will not affect the original variable that was passed in.</li>
      </ul>
    </section>

    <section>
      <h3>Looping Through Objects</h3>
      <ul>
        <li>The for...in loop is used to iterate over the properties of an object.</li>
        <li>It executes a given block of code for each property in the object.</li>
        <li>Syntax:</li>
        <li>for (let key in object) {
          // code to be executed
          }
        </li>
      </ul>
    </section>

    <section>
      <h3>Review: Objects</h3>
      <ul>
        <li>Objects store collections of key-value pairs.</li>
        <li>Each key-value pair is a property—when a property is a function it is known as a method.</li>
        <li>An object literal is composed of comma-separated key-value pairs surrounded by curly braces.</li>
        <li>You can access, add or edit a property within an object by using dot notation or bracket notation.</li>
        <li>We can add methods to our object literals using key-value syntax with anonymous function expressions as
          values or by using the new ES6 method syntax.</li>
        <li>We can navigate complex, nested objects by chaining operators. </li>
        <li>Objects are mutable—we can change their properties even when they’re declared with const.</li>
        <li>Objects are passed by reference— when we make changes to an object passed into a function, those changes are
          permanent. </li>
        <li>We can iterate through objects using the For...in syntax.</li>
      </ul>
    </section>

    <section>
      <h3></h3>
      <ul>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
      </ul>
    </section>

  </main>

</body>

</html>
